package Bootloader

/*
    First draft : Being able to send bytes through UART
        Needs to be able to send many bytes over UART
        Needs to determine structure of address and data. Maybe 32bit address followed by 32bit data for every word?
 */

import com.fazecast.jSerialComm._
import java.util.HexFormat
import scala.math.BigInt
import scala.io.Source
import scala.util.Try


object SendUART {
  def main(args: Array[String]): Unit = {
    // Identify available serial ports
    val ports = SerialPort.getCommPorts
    if (ports.length == 0) System.out.println("No COM ports found ;(")

    var foundPortName = "COM6" //Standard COM port found on Alexander PC
    for (port <- ports) {
      foundPortName = port.getSystemPortName //If other port found dynamically allocate
      System.out.println("Found Port: " + foundPortName)
    }

    val serialPort = SerialPort.getCommPort(foundPortName)
    serialPort.setBaudRate(115200) // Set baud rate (match with receiver)

    serialPort.setNumDataBits(8)
    serialPort.setNumStopBits(SerialPort.ONE_STOP_BIT)
    serialPort.setParity(SerialPort.NO_PARITY)

    if (!serialPort.openPort) {
      System.out.println("Failed to open port.")
      return
    }

    System.out.println("Port opened successfully.")
    // Send data
    // This byte array should contain the addresses and instructions for turning on the LED on the FPGA board

    //Simple test program using hardcoded data
    val data = Array[Byte](0xF0.toByte,0x01.toByte,0x00.toByte,0x00.toByte,0x00.toByte,0x00.toByte,0x00.toByte,0xFF.toByte,0xF1.toByte,0x00.toByte,0x00.toByte,0x00.toByte,0x00.toByte,0x00.toByte,0x00.toByte,0x01.toByte)
    for(i <- data.indices){
      serialPort.writeBytes(data.slice(i,i+1),1)
      System.out.println(data.slice(i,i+1).mkString("Array(", ", ", ")")) //Check what we are sending
      Thread.sleep(2000)
    }

    /*
    //Actual program which should take data from a file generated by the ELFHandler
    val filePath = "ELF_TRANSLATED.txt"
    try {
      val source = Source.fromFile(filePath)

      for (line <- source.getLines()) { // Reading file line by line
        val parts = line.trim.split("\\s+") // Splitting on one or more spaces

        val addressInt = parts(0).toInt
        val dataInt = parts(1).toInt

        val address: Array[Byte] = BigInt(addressInt).toByteArray
        val paddedaddress = address.reverse.padTo(4,0).reverse //Padding could be needed - we want 4 bytes always.

        val data: Array[Byte] = BigInt(dataInt).toByteArray
        val paddeddata = data.reverse.padTo(4,0).reverse //Padding could be needed - we want 4 bytes always.

        //send the Address to the serialport
        for(i <- paddedaddress.indices){
          serialPort.writeBytes(paddedaddress.slice(i,i+1),1)
          System.out.println(paddedaddress.slice(i,i+1).mkString("Address(", ", ", ")")) //Check what we are sending
          Thread.sleep(2000)
        }

        //send the data to the serialport
        for(i <- paddeddata.indices){
          serialPort.writeBytes(paddeddata.slice(i,i+1),1)
          System.out.println(paddeddata.slice(i,i+1).mkString("Address(", ", ", ")")) //Check what we are sending
          Thread.sleep(2000)
        }
      }
      source.close() // Make sure to close the file
    } catch {
      case ex: Exception => println(s"Error reading file: ${ex.getMessage}")
    }
    */


    System.out.println("Data sent.")
    serialPort.closePort
    System.out.println("Port closed.")
  }
}
